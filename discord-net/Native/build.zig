const std = @import("std");

fn extractFunc(line: []const u8) ?[]const u8 {
    const first_index = std.mem.indexOfScalar(u8, line, '(') orelse return null;
    var i: usize = first_index;
    while (i > 0) : (i -= 1) {
        if (line[i - 1] == ' ') {
            return line[i..first_index];
        }
    }
    return null;
}

fn getUid(alloc: std.mem.Allocator, file_path: []const u8) ![]u8 {
    var hasher = std.hash.Wyhash.init(0);
    hasher.update(file_path);
    const hash_val = hasher.final();
    return std.fmt.allocPrint(alloc, "{x}", .{hash_val});
}

fn loadModule(alloc: std.mem.Allocator, file_path: []const u8, writer: anytype) !void {
    var file = try std.fs.cwd().openFile(file_path, .{});
    defer file.close();

    var buff_read = std.io.bufferedReader(file.reader());
    const reader = buff_read.reader();

    var imported = false;
    const uid = try getUid(alloc, file_path);
    defer alloc.free(uid);

    var line_buf = std.ArrayList(u8).init(alloc);
    defer line_buf.deinit();
    // var line_buf: [4096]u8 = undefined;

    while (true) {
        line_buf.clearRetainingCapacity();
        reader.streamUntilDelimiter(line_buf.writer(), '\n', null) catch |err| switch (err) {
            error.EndOfStream => break,
            else => return err,
        };

        const line = line_buf.items;
        if (!std.mem.containsAtLeast(u8, line, 1, "callconv(.C)"))
            continue;

        if (extractFunc(line)) |name| {
            if (!imported) {
                try writer.print("\nconst _{s} = @import(\"{s}\");\n\n", .{
                    uid,
                    file_path,
                });
                imported = true;
            }
            try writer.print("export const {s} = _{s}.{s};\n", .{ name, uid, name });
        }
    }
}

fn genEntry(b: *std.Build, src_dir: []const u8, out: []const u8) !void {
    const alloc = b.allocator;

    //-+-+-+-+-+-+-+-+
    // Open Directory
    //-+-+-+-+-+-+-+-+
    var cwd = std.fs.cwd().openDir(src_dir, .{
        .iterate = true,
        .access_sub_paths = true,
    }) catch |err| {
        std.log.err("Could not open source directory: {s}\n{}", .{ src_dir, err });
        return err;
    };
    defer cwd.close();
    //-+-+-+-+-+-+-+-+

    //-+-+-+-+-+-+-+-+
    // Define Output File
    //-+-+-+-+-+-+-+-+
    var out_file = std.fs.cwd().createFile(out, .{
        .truncate = true,
    }) catch |err| {
        std.log.err("Could not create file: {s}\n{}", .{ out, err });
        return err;
    };
    defer out_file.close();
    //-+-+-+-+-+-+-+-+

    var buffered_writer = std.io.bufferedWriter(out_file.writer());
    const writer = buffered_writer.writer();
    // var writer = out_file.writer();
    try writer.writeAll(
        "// THIS FILE IS AUTO-GENERATED BY build.zig. DO NOT EDIT.\n",
    );

    var iter = cwd.iterate();
    while (try iter.next()) |entry| {
        if (entry.kind != .file)
            continue;

        if (!std.mem.endsWith(u8, entry.name, ".zig"))
            continue;

        // Construct full path
        const file_path = try std.fs.path.join(alloc, &.{ src_dir, entry.name });
        defer alloc.free(file_path);

        try loadModule(alloc, file_path, writer);
    }
    try buffered_writer.flush();
}

pub fn build(b: *std.Build) void {
    const entry_file = "__root.zig";
    genEntry(
        b,
        "src/",
        entry_file,
    ) catch |err| {
        std.log.err("Error generating {s}: {}", .{ entry_file, err });
        std.process.exit(1);
    };

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    const lib = b.addSharedLibrary(.{
        .name = "Native",
        .root_source_file = b.path(entry_file),
        .target = target,
        .optimize = optimize,
    });
    lib.addCSourceFiles(.{
        .files = &.{
            "src/Hello.cc",
            "swig_wrap.cxx",
        },
        .flags = &.{
            "-std=c++20",
            "-fexperimental-library",
            "-Wall",
            "-Wextra",
            "-Wpedantic",
        },
    });
    lib.linkLibC();
    lib.linkLibCpp();
    b.installArtifact(lib);
}
