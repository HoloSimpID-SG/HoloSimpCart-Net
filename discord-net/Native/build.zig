const std = @import("std");
const zcc = @import("compile_commands");

fn extractFunc(line: []const u8) ?[]const u8 {
    const first_index = std.mem.indexOfScalar(u8, line, '(') orelse return null;
    var i: usize = first_index;
    while (i > 0) : (i -= 1) {
        if (line[i - 1] == ' ') {
            return line[i..first_index];
        }
    }
    return null;
}

fn getUid(alloc: std.mem.Allocator, file_path: []const u8) ![]u8 {
    var hasher = std.hash.Wyhash.init(0);
    hasher.update(file_path);
    const hash_val = hasher.final();
    return std.fmt.allocPrint(alloc, "{x}", .{hash_val});
}

fn loadModule(alloc: std.mem.Allocator, file_path: []const u8, writer: *std.io.Writer) !void {
    var file = try std.fs.cwd().openFile(file_path, .{
        .mode = .read_only,
    });
    defer file.close();

    const file_contents = try std.fs.cwd().readFileAlloc(alloc, file_path, 64 * 1024 * 1024);
    defer alloc.free(file_contents);

    var line_iter = std.mem.splitScalar(u8, file_contents, '\n');
    var imported = false;

    const uid = try getUid(alloc, file_path);
    defer alloc.free(uid);

    while (line_iter.next()) |line| {
        if (!std.mem.containsAtLeast(u8, line, 1, "callconv(.c)"))
            continue;
        if (extractFunc(line)) |name| {
            if (!imported) {
                imported = true;
                try writer.print(
                    "\nconst _{s} = @import(\"{s}\");\n\n",
                    .{ uid, file_path },
                );
            }
            try writer.print("export const {s} = _{s}.{s};\n", .{ name, uid, name });
        }
    }
}

fn genEntry(b: *std.Build, src_dir: []const u8, out: []const u8) !void {
    const alloc = b.allocator;

    //================
    // Open Source Directory
    //================
    var cwd = std.fs.cwd().openDir(src_dir, .{
        .iterate = true,
        .access_sub_paths = true,
    }) catch |err| {
        std.log.err("Could not open source directory: {s}\n{}", .{ src_dir, err });
        return err;
    };
    defer cwd.close();
    //================

    //================
    // Define Output File
    //================
    var out_file = std.fs.cwd().createFile(out, .{
        .truncate = true,
    }) catch |err| {
        std.log.err("Could not create file: {s}\n{}", .{ out, err });
        return err;
    };
    defer out_file.close();
    //================

    var write_buffer: [4096]u8 = undefined;
    var writer_ = out_file.writer(&write_buffer);
    const writer = &writer_.interface;

    try writer.writeAll(
        "// THIS FILE IS AUTO-GENERATED BY build.zig. DO NOT EDIT.\n",
    );
    try writer.flush();

    var iter = cwd.iterate();
    while (try iter.next()) |entry| {
        if (entry.kind != .file)
            continue;

        if (!std.mem.endsWith(u8, entry.name, ".zig"))
            continue;

        // Construct full path
        const file_path = try std.fs.path.join(alloc, &.{ src_dir, entry.name });
        defer alloc.free(file_path);

        try loadModule(alloc, file_path, writer);
    }
    try writer.flush();
}

pub fn build(b: *std.Build) !void {
    const entry_file = "__root.zig";
    genEntry(
        b,
        "src/",
        entry_file,
    ) catch |err| {
        std.log.err("Error generating {s}: {}", .{ entry_file, err });
        std.process.exit(1);
    };

    var targets = std.ArrayList(*std.Build.Step.Compile){};

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    const mod = b.createModule(.{
        .root_source_file = b.path(entry_file),
        .target = target,
        .optimize = optimize,
        .link_libc = true,
        .link_libcpp = true,
    });
    mod.addCSourceFiles(.{
        .files = &.{
            "src/Hello.cc",
            "swig_wrap.cxx",
        },
        .flags = &.{
            "-std=c++20",
            "-fexperimental-library",
            "-Wall",
            "-Wextra",
            "-Wpedantic",
            "-fPIC", // Zig Compile to Dynamic
        },
    });

    const boost_dep = b.dependency("boost", .{
        .target = target,
        .optimize = optimize,
    });
    const boost_artifact = boost_dep.artifact("boost");

    for (boost_artifact.root_module.include_dirs.items) |include_dir| {
        try mod.include_dirs.append(b.allocator, include_dir);
    }
    mod.linkLibrary(boost_artifact);

    const lib = b.addLibrary(.{
        .name = "Native",
        .linkage = .dynamic,
        .root_module = mod,
    });
    b.installArtifact(lib);

    try targets.append(b.allocator, lib);
    var cc_step = zcc.createStep(b, "cdb", try targets.toOwnedSlice(b.allocator));
    cc_step.dependOn(&boost_artifact.step);
}
